/***********************************************************************
 *   DL_MESO       Version 2.6                                         *
 *   Authors   :   R. S. Qin, M. A. Seaton                             *
 *   Copyright :   STFC Daresbury Laboratory                           *
 *             :   07/08/2014                                          *
 ***********************************************************************
 *   This extract used with permission of the copyright owners         *
 ***********************************************************************
 *   The full DL_MESO package is supplied to individuals under an      *
 *   academic licence, which is free of cost to academic scientists    *
 *   pursuing scientific research of a non-commercial nature           *
 *   To register please visit www.ccp5.ac.uk/DL_MESO                   *
 *   Commercial organisations interested in acquiring the package      *
 *   should approach Dr. M. A. Seaton at Daresbury Laboratory in the   *
 *   first instance. Daresbury Laboratory is the sole centre for       * 
 *   distribution of the package                                       *
 ***********************************************************************/


// D2Q9, D3Q15, D3Q19 and D3Q27 models

int D2Q9()
{
  int i;
  
  lbcs = 1.0/sqrt(3.0);
  lbcssq = 1.0/3.0;
  lbrcssq = 3.0;

  lbw[0]=4.0/9.0;
  
  for(i=1; i<5; i++) {
    lbw[2*i]=1.0/9.0;
    lbw[2*i-1]=1.0/36.0;
  }

  lbv[0]=0;    lbv[1]=0;    lbv[2]=0;

  lbv[3]=-1;   lbv[4]=1;    lbv[5]=0;
  lbv[6]=-1;   lbv[7]=0;    lbv[8]=0;
  lbv[9]=-1;   lbv[10]=-1;  lbv[11]=0;
  lbv[12]=0;   lbv[13]=-1;  lbv[14]=0;

  lbv[15]=1;   lbv[16]=-1;  lbv[17]=0;
  lbv[18]=1;   lbv[19]=0;   lbv[20]=0;
  lbv[21]=1;   lbv[22]=1;   lbv[23]=0;
  lbv[24]=0;   lbv[25]=1;   lbv[26]=0;
  
  lbopv[0]=0;  lbopv[1]=5;  lbopv[2]=6;
  lbopv[3]=7;  lbopv[4]=8;  lbopv[5]=1;
  lbopv[6]=2;  lbopv[7]=3;  lbopv[8]=4;
    
  lbvw[0] = lbvw[1] = lbvw[2] = 0.0;
  for(i=1; i<9; i++) {
    lbvw[3*i]   = lbv[3*i]   * lbw[i];
    lbvw[3*i+1] = lbv[3*i+1] * lbw[i];
    lbvw[3*i+2] = lbv[3*i+2] * lbw[i];
  }

// MRT scheme transformation matrix

   double trd2q9[81] =  { 1,  1,  1,  1,  1,  1,  1,  1,  1, 
                         -4,  2, -1,  2, -1,  2, -1,  2, -1, 
                          4,  1, -2,  1, -2,  1, -2,  1, -2,
                          0, -1, -1, -1,  0,  1,  1,  1,  0,
                          0, -1,  2, -1,  0,  1, -2,  1,  0,
                          0,  1,  0, -1, -1, -1,  0,  1,  1,
                          0,  1,  0, -1,  2, -1,  0,  1, -2,
                          0,  0,  1,  0, -1,  0,  1,  0, -1,
                          0, -1,  0,  1,  0, -1,  0,  1,  0 };

  std::copy (trd2q9, trd2q9+lbsy.nq*lbsy.nq, lbtr);

// MRT scheme inverse transformation matrix

  double trinvd2q9[81] = { 1.0/9.0,  -1.0/9.0,   1.0/9.0,        0,        0,        0,         0,     0,     0,
                           1.0/9.0,  1.0/18.0,  1.0/36.0, -1.0/6.0,-1.0/12.0,  1.0/6.0,  1.0/12.0,     0, -0.25,
                           1.0/9.0, -1.0/36.0, -1.0/18.0, -1.0/6.0,  1.0/6.0,        0,         0,  0.25,     0,
                           1.0/9.0,  1.0/18.0,  1.0/36.0, -1.0/6.0,-1.0/12.0, -1.0/6.0, -1.0/12.0,     0,  0.25,
                           1.0/9.0, -1.0/36.0, -1.0/18.0,        0,        0, -1.0/6.0,   1.0/6.0, -0.25,     0,
                           1.0/9.0,  1.0/18.0,  1.0/36.0,  1.0/6.0, 1.0/12.0, -1.0/6.0, -1.0/12.0,     0, -0.25,
                           1.0/9.0, -1.0/36.0, -1.0/18.0,  1.0/6.0, -1.0/6.0,        0,         0,  0.25,     0,
                           1.0/9.0,  1.0/18.0,  1.0/36.0,  1.0/6.0, 1.0/12.0,  1.0/6.0,  1.0/12.0,     0,  0.25,
                           1.0/9.0, -1.0/36.0, -1.0/18.0,        0,        0,  1.0/6.0,  -1.0/6.0, -0.25,     0  };

  std::copy (trinvd2q9, trinvd2q9+lbsy.nq*lbsy.nq, lbtrinv);

// MRT collision and moment parameters

  lbmrts[0] = 1.14;  // s2   - tuneable collision parameter
  lbmrts[1] = 1.92;  // s4   - tuneable collision parameter

  lbmrtw[0] = 1.0;   // w_e  - moment parameter
  lbmrtw[1] = -3.0;  // w_ej - moment parameter

  if(lbdm.rank == 0)
    cout << "armed with D2Q9 LB model" << endl;
  
  return 0;

}

int D3Q15()
{
  int i;

  lbcs = 1.0/sqrt(3.0);
  lbcssq = 1.0/3.0;
  lbrcssq = 3.0;

  lbw[0]=2.0/9.0;

  for(i=1; i<4; i++) {
    lbw[i]=1.0/9.0;
    lbw[i+7]=1.0/9.0;
  }

  for(i=4; i<8; i++) {
    lbw[i]=1.0/72.0;
    lbw[i+7]=1.0/72.0;
  }
  
  lbv[0]=0;    lbv[1]=0;    lbv[2]=0;

  lbv[3]=-1;   lbv[4]=0;    lbv[5]=0;
  lbv[6]=0;    lbv[7]=-1;   lbv[8]=0;
  lbv[9]=0;    lbv[10]=0;   lbv[11]=-1;
  lbv[12]=-1;  lbv[13]=-1;  lbv[14]=-1;
  lbv[15]=-1;  lbv[16]=-1;  lbv[17]=1;
  lbv[18]=-1;  lbv[19]=1;   lbv[20]=-1;
  lbv[21]=-1;  lbv[22]=1;   lbv[23]=1;

  lbv[24]=1;   lbv[25]=0;   lbv[26]=0;
  lbv[27]=0;   lbv[28]=1;   lbv[29]=0;
  lbv[30]=0;   lbv[31]=0;   lbv[32]=1;
  lbv[33]=1;   lbv[34]=1;   lbv[35]=1;
  lbv[36]=1;   lbv[37]=1;   lbv[38]=-1;
  lbv[39]=1;   lbv[40]=-1;  lbv[41]=1;
  lbv[42]=1;   lbv[43]=-1;  lbv[44]=-1;
  
  lbopv[0]=0;  lbopv[1]=8;  lbopv[2]=9;
  lbopv[3]=10; lbopv[4]=11; lbopv[5]=12;
  lbopv[6]=13; lbopv[7]=14; lbopv[8]=1;
  lbopv[9]=2;  lbopv[10]=3; lbopv[11]=4;
  lbopv[12]=5; lbopv[13]=6; lbopv[14]=7;

  lbvw[0] = lbvw[1] = lbvw[2] = 0.0;
  for(i=1; i<15; i++) {
    lbvw[3*i]   = lbv[3*i]   * lbw[i];
    lbvw[3*i+1] = lbv[3*i+1] * lbw[i];
    lbvw[3*i+2] = lbv[3*i+2] * lbw[i];
  }

// MRT scheme transformation matrix

  double trd3q15[] = {  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
                       -2, -1, -1, -1,  1,  1,  1,  1, -1, -1, -1,  1,  1,  1,  1,
                       16, -4, -4, -4,  1,  1,  1,  1, -4, -4, -4,  1,  1,  1,  1,
                        0, -1,  0,  0, -1, -1, -1, -1,  1,  0,  0,  1,  1,  1,  1,
                        0,  4,  0,  0, -1, -1, -1, -1, -4,  0,  0,  1,  1,  1,  1,
                        0,  0, -1,  0, -1, -1,  1,  1,  0,  1,  0,  1,  1, -1, -1,
                        0,  0,  4,  0, -1, -1,  1,  1,  0, -4,  0,  1,  1, -1, -1,
                        0,  0,  0, -1, -1,  1, -1,  1,  0,  0,  1,  1, -1,  1, -1,
                        0,  0,  0,  4, -1,  1, -1,  1,  0,  0, -4,  1, -1,  1, -1,
                        0,  2, -1, -1,  0,  0,  0,  0,  2, -1, -1,  0,  0,  0,  0,
                        0,  0,  1, -1,  0,  0,  0,  0,  0,  1, -1,  0,  0,  0,  0,
                        0,  0,  0,  0,  1,  1, -1, -1,  0,  0,  0,  1,  1, -1, -1,
                        0,  0,  0,  0,  1, -1, -1,  1,  0,  0,  0,  1, -1, -1,  1,
                        0,  0,  0,  0,  1, -1,  1, -1,  0,  0,  0,  1, -1,  1, -1,
                        0,  0,  0,  0, -1,  1,  1, -1,  0,  0,  0,  1, -1, -1,  1 };

  std::copy (trd3q15, trd3q15+lbsy.nq*lbsy.nq, lbtr);

// MRT scheme inverse transformation matrix

  double trinvd3q15[] = { 1.0/15.0,  -1.0/9.0,  2.0/45.0,    0,      0,    0,      0,    0,      0,         0,     0,      0,      0,      0,      0,
                          1.0/15.0, -1.0/18.0, -1.0/90.0, -0.1,    0.1,    0,      0,    0,      0,   1.0/6.0,     0,      0,      0,      0,      0,
                          1.0/15.0, -1.0/18.0, -1.0/90.0,    0,      0  -0.1,    0.1,    0,      0, -1.0/12.0,  0.25,      0,      0,      0,      0,
                          1.0/15.0, -1.0/18.0, -1.0/90.0,    0,      0,    0,      0, -0.1,    0.1, -1.0/12.0, -0.25,      0,      0,      0,      0,
                          1.0/15.0,  1.0/18.0, 1.0/360.0, -0.1, -0.025, -0.1, -0.025, -0.1, -0.025,         0,     0,  0.125,  0.125,  0.125, -0.125,
                          1.0/15.0,  1.0/18.0, 1.0/360.0, -0.1, -0.025, -0.1, -0.025,  0.1,  0.025,         0,     0,  0.125, -0.125, -0.125,  0.125,
                          1.0/15.0,  1.0/18.0, 1.0/360.0, -0.1, -0.025,  0.1,  0.025, -0.1, -0.025,         0,     0, -0.125, -0.125,  0.125,  0.125,
                          1.0/15.0,  1.0/18.0, 1.0/360.0, -0.1, -0.025,  0.1,  0.025,  0.1,  0.025,         0,     0, -0.125,  0.125, -0.125, -0.125,
                          1.0/15.0, -1.0/18.0, -1.0/90.0,  0.1,   -0.1,    0,      0,    0,      0,   1.0/6.0,     0,      0,      0,      0,      0,
                          1.0/15.0, -1.0/18.0, -1.0/90.0,    0,      0,  0.1,   -0.1,    0,      0, -1.0/12.0,  0.25,      0,      0,      0,      0,
                          1.0/15.0, -1.0/18.0, -1.0/90.0,    0,      0,    0,      0,  0.1,   -0.1, -1.0/12.0, -0.25,      0,      0,      0,      0,
                          1.0/15.0,  1.0/18.0, 1.0/360.0,  0.1,  0.025,  0.1,  0.025,  0.1,  0.025,         0,     0,  0.125,  0.125,  0.125,  0.125,
                          1.0/15.0,  1.0/18.0, 1.0/360.0,  0.1,  0.025,  0.1,  0.025, -0.1, -0.025,         0,     0,  0.125, -0.125, -0.125, -0.125,
                          1.0/15.0,  1.0/18.0, 1.0/360.0,  0.1,  0.025, -0.1, -0.025,  0.1,  0.025,         0,     0, -0.125, -0.125,  0.125, -0.125,
                          1.0/15.0,  1.0/18.0, 1.0/360.0,  0.1,  0.025, -0.1, -0.025, -0.1, -0.025,         0,     0, -0.125,  0.125, -0.125,  0.125 };

  std::copy (trinvd3q15, trinvd3q15+lbsy.nq*lbsy.nq, lbtrinv);

// MRT collision and moment parameters

  lbmrts[0] = 1.2;   // s2   - tuneable collision parameter
  lbmrts[1] = 1.6;   // s4   - tuneable collision parameter
  lbmrts[2] = 1.2;   // s14  - tuneable collision parameter

  lbmrtw[0] = 1.0;   // w_e  - moment parameter
  lbmrtw[1] = -5.0;  // w_ej - moment parameter

  if(lbdm.rank == 0)
    cout << "armed with D3Q15 LB model" << endl;
  
  return 0;
  
}

int D3Q19()
{
  int i;

  lbcs = 1.0/sqrt(3.0);
  lbcssq = 1.0/3.0;
  lbrcssq = 3.0;

  lbw[0]=1.0/3.0;

  for(i=1; i<4; i++) {
    lbw[i]=1.0/18.0;
    lbw[i+9]=1.0/18.0;
  }

  for(i=4; i<10; i++) {
    lbw[i]=1.0/36.0;
    lbw[i+9]=1.0/36.0;
  }

  lbv[0]=0;    lbv[1]=0;    lbv[2]=0;

  lbv[3]=-1;   lbv[4]=0;    lbv[5]=0;
  lbv[6]=0;    lbv[7]=-1;   lbv[8]=0;
  lbv[9]=0;    lbv[10]=0;   lbv[11]=-1;
  lbv[12]=-1;  lbv[13]=-1;  lbv[14]=0;
  lbv[15]=-1;  lbv[16]=1;   lbv[17]=0;
  lbv[18]=-1;  lbv[19]=0;   lbv[20]=-1;
  lbv[21]=-1;  lbv[22]=0;   lbv[23]=1;
  lbv[24]=0;   lbv[25]=-1;  lbv[26]=-1;
  lbv[27]=0;   lbv[28]=-1;  lbv[29]=1;

  lbv[30]=1;   lbv[31]=0;   lbv[32]=0;
  lbv[33]=0;   lbv[34]=1;   lbv[35]=0;
  lbv[36]=0;   lbv[37]=0;   lbv[38]=1;
  lbv[39]=1;   lbv[40]=1;   lbv[41]=0;
  lbv[42]=1;   lbv[43]=-1;  lbv[44]=0;
  lbv[45]=1;   lbv[46]=0;   lbv[47]=1;
  lbv[48]=1;   lbv[49]=0;   lbv[50]=-1;
  lbv[51]=0;   lbv[52]=1;   lbv[53]=1;
  lbv[54]=0;   lbv[55]=1;   lbv[56]=-1;

  lbopv[0]=0;  lbopv[1]=10; lbopv[2]=11;
  lbopv[3]=12; lbopv[4]=13; lbopv[5]=14;
  lbopv[6]=15; lbopv[7]=16; lbopv[8]=17;
  lbopv[9]=18; lbopv[10]=1; lbopv[11]=2;
  lbopv[12]=3; lbopv[13]=4; lbopv[14]=5;
  lbopv[15]=6; lbopv[16]=7; lbopv[17]=8;
  lbopv[18]=9;

  lbvw[0] = lbvw[1] = lbvw[2] = 0.0;
  for(i=1; i<19; i++) {
    lbvw[3*i]   = lbv[3*i]   * lbw[i];
    lbvw[3*i+1] = lbv[3*i+1] * lbw[i];
    lbvw[3*i+2] = lbv[3*i+2] * lbw[i];
  }

// MRT scheme transformation matrix

  double trd3q19[] = {  1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
                      -30, -11, -11, -11,   8,   8,   8,   8,   8,   8, -11, -11, -11,   8,   8,   8,   8,   8,   8,
                       12,  -4,  -4,  -4,   1,   1,   1,   1,   1,   1,  -4,  -4,  -4,   1,   1,   1,   1,   1,   1,
                        0,  -1,   0,   0,  -1,  -1,  -1,  -1,   0,   0,   1,   0,   0,   1,   1,   1,   1,   0,   0,
                        0,   4,   0,   0,  -1,  -1,  -1,  -1,   0,   0,  -4,   0,   0,   1,   1,   1,   1,   0,   0,
                        0,   0,  -1,   0,  -1,   1,   0,   0,  -1,  -1,   0,   1,   0,   1,  -1,   0,   0,   1,   1,
                        0,   0,   4,   0,  -1,   1,   0,   0,  -1,  -1,   0,  -4,   0,   1,  -1,   0,   0,   1,   1,
                        0,   0,   0,  -1,   0,   0,  -1,   1,  -1,   1,   0,   0,   1,   0,   0,   1,  -1,   1,  -1,
                        0,   0,   0,   4,   0,   0,  -1,   1,  -1,   1,   0,   0,  -4,   0,   0,   1,  -1,   1,  -1,
                        0,   2,  -1,  -1,   1,   1,   1,   1,  -2,  -2,   2,  -1,  -1,   1,   1,   1,   1,  -2,  -2,
                        0,  -4,   2,   2,   1,   1,   1,   1,  -2,  -2,  -4,   2,   2,   1,   1,   1,   1,  -2,  -2,
                        0,   0,   1,  -1,   1,   1,  -1,  -1,   0,   0,   0,   1,  -1,   1,   1,  -1,  -1,   0,   0,
                        0,   0,  -2,   2,   1,   1,  -1,  -1,   0,   0,   0,  -2,   2,   1,   1,  -1,  -1,   0,   0,
                        0,   0,   0,   0,   1,  -1,   0,   0,   0,   0,   0,   0,   0,   1,  -1,   0,   0,   0,   0,
                        0,   0,   0,   0,   0,   0,   0,   0,   1,  -1,   0,   0,   0,   0,   0,   0,   0,   1,  -1,
                        0,   0,   0,   0,   0,   0,   1,  -1,   0,   0,   0,   0,   0,   0,   0,   1,  -1,   0,   0,
                        0,   0,   0,   0,  -1,  -1,   1,   1,   0,   0,   0,   0,   0,   1,   1,  -1,  -1,   0,   0,
                        0,   0,   0,   0,   1,  -1,   0,   0,  -1,  -1,   0,   0,   0,  -1,   1,   0,   0,   1,   1,
                        0,   0,   0,   0,   0,   0,  -1,   1,   1,  -1,   0,   0,   0,   0,   0,   1,  -1,  -1,   1 };

  std::copy (trd3q19, trd3q19+lbsy.nq*lbsy.nq, lbtr);

// MRT scheme inverse transformation matrix

  double trinvd3q19[] = { 1.0/19.0,  -10.0/798.0,  1.0/21.0,    0,      0,    0,      0,    0,      0,         0,         0,         0,         0,     0,     0,     0,      0,      0,      0,
                          1.0/19.0, -33.0/7182.0, -1.0/63.0, -0.1,    0.1,    0,      0,    0,      0,  1.0/18.0, -1.0/18.0,         0,         0,     0,     0,     0,      0,      0,      0,
                          1.0/19.0, -33.0/7182.0, -1.0/63.0,    0,      0, -0.1,    0.1,    0,      0, -1.0/36.0,  1.0/36.0,  1.0/12.0, -1.0/12.0,     0,     0,     0,      0,      0,      0,
                          1.0/19.0, -33.0/7182.0, -1.0/63.0,    0,      0,    0,      0, -0.1,    0.1, -1.0/36.0,  1.0/36.0, -1.0/12.0,  1.0/12.0,     0,     0,     0,      0,      0,      0,
                          1.0/19.0,   4.0/1197.0, 1.0/252.0, -0.1, -0.025, -0.1, -0.025,    0,      0,  1.0/36.0,  1.0/72.0,  1.0/12.0,  1.0/24.0,  0.25,     0,     0, -0.125,  0.125,      0,
                          1.0/19.0,   4.0/1197.0, 1.0/252.0, -0.1, -0.025,  0.1,  0.025,    0,      0,  1.0/36.0,  1.0/72.0,  1.0/12.0,  1.0/24.0, -0.25,     0,     0, -0.125, -0.125,      0,
                          1.0/19.0,   4.0/1197.0, 1.0/252.0, -0.1, -0.025,    0,      0, -0.1, -0.025,  1.0/36.0,  1.0/72.0, -1.0/12.0, -1.0/24.0,     0,     0,  0.25,  0.125,      0, -0.125,
                          1.0/19.0,   4.0/1197.0, 1.0/252.0, -0.1, -0.025,    0,      0,  0.1,  0.025,  1.0/36.0,  1.0/72.0, -1.0/12.0, -1.0/24.0,     0,     0, -0.25,  0.125,      0,  0.125,
                          1.0/19.0,   4.0/1197.0, 1.0/252.0,    0,      0, -0.1, -0.025, -0.1, -0.025, -1.0/18.0, -1.0/36.0,         0,         0,     0,  0.25,     0,      0, -0.125,  0.125,
                          1.0/19.0,   4.0/1197.0, 1.0/252.0,    0,      0, -0.1, -0.025,  0.1,  0.025, -1.0/18.0, -1.0/36.0,         0,         0,     0, -0.25,     0,      0, -0.125, -0.125,
                          1.0/19.0, -33.0/7182.0, -1.0/63.0,  0.1,   -0.1,    0,      0,    0,      0,  1.0/18.0, -1.0/18.0,         0,         0,     0,     0,     0,      0,      0,      0,
                          1.0/19.0, -33.0/7182.0, -1.0/63.0,    0,      0,  0.1,   -0.1,    0,      0, -1.0/36.0,  1.0/36.0,  1.0/12.0, -1.0/12.0,     0,     0,     0,      0,      0,      0,
                          1.0/19.0, -33.0/7182.0, -1.0/63.0,    0,      0,    0,      0,  0.1,   -0.1, -1.0/36.0,  1.0/36.0, -1.0/12.0,  1.0/12.0,     0,     0,     0,      0,      0,      0,
                          1.0/19.0,   4.0/1197.0, 1.0/252.0,  0.1,  0.025,  0.1,  0.025,    0,      0,  1.0/36.0,  1.0/72.0,  1.0/12.0,  1.0/24.0,  0.25,     0,     0,  0.125, -0.125,      0,
                          1.0/19.0,   4.0/1197.0, 1.0/252.0,  0.1,  0.025, -0.1, -0.025,    0,      0,  1.0/36.0,  1.0/72.0,  1.0/12.0,  1.0/24.0, -0.25,     0,     0,  0.125,  0.125,      0,
                          1.0/19.0,   4.0/1197.0, 1.0/252.0,  0.1,  0.025,    0,      0,  0.1,  0.025,  1.0/36.0,  1.0/72.0, -1.0/12.0, -1.0/24.0,     0,     0,  0.25, -0.125,      0,  0.125,
                          1.0/19.0,   4.0/1197.0, 1.0/252.0,  0.1,  0.025,    0,      0, -0.1, -0.025,  1.0/36.0,  1.0/72.0, -1.0/12.0, -1.0/24.0,     0,     0, -0.25, -0.125,      0, -0.125,
                          1.0/19.0,   4.0/1197.0, 1.0/252.0,    0,      0,  0.1,  0.025,  0.1,  0.025, -1.0/18.0, -1.0/36.0,         0,         0,     0,  0.25,     0,      0,  0.125, -0.125,
                          1.0/19.0,   4.0/1197.0, 1.0/252.0,    0,      0,  0.1,  0.025, -0.1, -0.025, -1.0/18.0, -1.0/36.0,         0,         0,     0, -0.25,     0,      0,  0.125,  0.125 };

  std::copy (trinvd3q19, trinvd3q19+lbsy.nq*lbsy.nq, lbtrinv);

// MRT collision and moment parameters

  lbmrts[0] = 1.4;   // s2   - tuneable collision parameter
  lbmrts[1] = 1.2;   // s4   - tuneable collision parameter
  lbmrts[2] = 1.98;  // s16  - tuneable collision parameter

  lbmrtw[0] = 3.0;   // w_e  - moment parameter
  lbmrtw[1] = -5.5;  // w_ej - moment parameter
  lbmrtw[2] = -0.5;  // w_xx - moment parameter

  if(lbdm.rank == 0)
    cout << "armed with D3Q19 LB model" << endl;

  return 0;

}


int D3Q27()
{
  int i;

  lbcs = 1.0/sqrt(3.0);
  lbcssq = 1.0/3.0;
  lbrcssq = 3.0;

  lbw[0]=8.0/27.0;
  
  for(i=1; i<4; i++) {
    lbw[i]=2.0/27.0;
    lbw[i+13]=2.0/27.0;
  }

  for(i=4; i<10; i++) {
    lbw[i]=1.0/54.0;
    lbw[i+13]=1.0/54.0;
  }

  for(i=10; i<14; i++) {
    lbw[i]=1.0/216.0;
    lbw[i+13]=1.0/216.0;
  }
  
  lbv[0]=0;    lbv[1]=0;    lbv[2]=0;

  lbv[3]=-1;   lbv[4]=0;    lbv[5]=0;
  lbv[6]=0;    lbv[7]=-1;   lbv[8]=0;
  lbv[9]=0;    lbv[10]=0;   lbv[11]=-1;
  lbv[12]=-1;  lbv[13]=-1;  lbv[14]=0;
  lbv[15]=-1;  lbv[16]=1;   lbv[17]=0;
  lbv[18]=-1;  lbv[19]=0;   lbv[20]=-1;
  lbv[21]=-1;  lbv[22]=0;   lbv[23]=1;
  lbv[24]=0;   lbv[25]=-1;  lbv[26]=-1;
  lbv[27]=0;   lbv[28]=-1;  lbv[29]=1;
  lbv[30]=-1;  lbv[31]=-1;  lbv[32]=-1;
  lbv[33]=-1;  lbv[34]=-1;  lbv[35]=1;
  lbv[36]=-1;  lbv[37]=1;   lbv[38]=-1;
  lbv[39]=-1;  lbv[40]=1;   lbv[41]=1;

  lbv[42]=1;   lbv[43]=0;   lbv[44]=0;
  lbv[45]=0;   lbv[46]=1;   lbv[47]=0;
  lbv[48]=0;   lbv[49]=0;   lbv[50]=1;
  lbv[51]=1;   lbv[52]=1;   lbv[53]=0;
  lbv[54]=1;   lbv[55]=-1;  lbv[56]=0;
  lbv[57]=1;   lbv[58]=0;   lbv[59]=1;
  lbv[60]=1;   lbv[61]=0;   lbv[62]=-1;
  lbv[63]=0;   lbv[64]=1;   lbv[65]=1;
  lbv[66]=0;   lbv[67]=1;   lbv[68]=-1;
  lbv[69]=1;   lbv[70]=1;   lbv[71]=1;
  lbv[72]=1;   lbv[73]=1;   lbv[74]=-1;
  lbv[75]=1;   lbv[76]=-1;  lbv[77]=1;
  lbv[78]=1;   lbv[79]=-1;  lbv[80]=-1;
  
  lbopv[0]=0;   lbopv[1]=14;  lbopv[2]=15;
  lbopv[3]=16;  lbopv[4]=17;  lbopv[5]=18;
  lbopv[6]=19;  lbopv[7]=20;  lbopv[8]=21;
  lbopv[9]=22;  lbopv[10]=23; lbopv[11]=24;
  lbopv[12]=25; lbopv[13]=26; lbopv[14]=1;
  lbopv[15]=2;  lbopv[16]=3;  lbopv[17]=4;
  lbopv[18]=5;  lbopv[19]=6;  lbopv[20]=7;
  lbopv[21]=8;  lbopv[22]=9;  lbopv[23]=10;
  lbopv[24]=11; lbopv[25]=12; lbopv[26]=13;

  lbvw[0] = lbvw[1] = lbvw[2] = 0.0;
  for(i=1; i<27; i++) {
    lbvw[3*i]   = lbv[3*i]   * lbw[i];
    lbvw[3*i+1] = lbv[3*i+1] * lbw[i];
    lbvw[3*i+2] = lbv[3*i+2] * lbw[i];
  }

// note: no MRT scheme available for D3Q27
  
  if(lbdm.rank == 0)
    cout << "armed with D3Q27 LB model" << endl;
  
  return 0;
  
}


